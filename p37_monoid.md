**Monoid**

`Monoid` - это `Semigroup` с нейтральным элементом. Нейтральность элемента означает, что `x <> id = x` и `id <> x = x` (`id` от `identity`). 
Нейтральный элемент даёт пустое (нулевое) состояние для обработки коллекций - свёрток, композиций, и позволяет работать с пустыми списками. `Semigroup` же подходит для случаев, когда у типа нет пустого состояния или оно бессмысленно.
```haskell 
class Semigroup a => Monoid a where
  mempty :: a -- нейтральный элемент
  mappend :: a -> a -> a -- композиция (<>)
  mconcat :: [a] -> a
```

Для сложения целых чисел нейтральным элементом будет `0`, для умножения - `1`. 
```haskell 
instance Monoid Integer where
  mappend = (+)
  mempty = 0
  
-- или (но не одновременно)
instance Monoid Integer where
  mappend = (*)
  mempty = 1
```

Для определения экземпляра `Monoid` минимальным полным определением являются `mempty` и `mappend`, а `mconcat` определяется автоматически:
```haskell
mconcat = foldr mappend mempty
```

У класса `Monoid` есть свои законы:
1. `mappend mempty x = x` и `mappend x mempty = x` - если что-то прибавить к пустому элементу, то это что-то и получим
2. `mappend x (mappend y z) = mappend (mappend x y) z` - ассоциативность
3. `mconcat = foldr mappend mempty` - определение `mconcat` из минимального полного определения класса.

Многие встроенные функции haskell требуют, чтобы типом аргумента был экземпляр `Monoid`. `Monoid` используется для свёрток через функции `fold` и `foldMap` (например суммирование чисел, склеивание строк), накопления результатов в рекурсивных алгоритмах, параллельных обработок (а-ля MapReduce). `Semigroup` часто в этих случаях не подходит потому что может быть пустой список для свёртки, пустой результат на определённом этапе, пустое дерево и т.д., а обрабатывать вручную случай для проверки на пустоту не хочется.
Пример:
```haskell
totalSalary :: [Int] -> Int
totalSalary = getSum . foldMap Sum

totalSalary [3000, 4000, 5000]
totalSalary [] 
```
