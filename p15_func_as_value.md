**Функции как значения первого класса**
Функции в haskell выступают как полноценные значения, которые можно передавать как аргумент в другие функции, возвращать из функций, присваивать переменным.

**Функции как аргументы**
Передача функций как аргументов позволяет обобщить процесс повторяющихся вычислений.
Допустим у нас есть функция `ifEvenInc`, которая увеличивает число `n` на единицу, если оно чётное, оставляя его неизменным в противном случае:
```haskell
module Main (main) where

ifEvenInc :: Int -> Int
ifEvenInc n = if even n
  then n+1
  else n

main :: IO ()
main = do
  putStrLn $ show $ ifEvenInc 20
```

Если позже нам понадобятся функции ifEvenDouble и ifEvenSquare, то мы будем вынуждены дублировать условие, а когда оно измениться, то переписывать синхронно все эти функции.
НО можно параметризовать функцию `ifEven...`, передав ей в качестве аргумента функцию-модификатор для `x`.
```haskel 
module Main (main) where

ifEven :: (Int -> Int) -> Int -> Int
ifEven func x = if even x
  then func x
  else x

ifEvenInc :: Int -> Int
ifEvenInc n = ifEven (\x -> x+1) n

main :: IO ()
main = do
  putStrLn $ show $ ifEvenInc 20
```

Не стоит забывать, что лямбда-функции - это полноценные функции и их так же можно передавать как значение.
Наиболее частым примером такого использования функций, не только в haskell, но и в других языках, является сортировка пользовательских типов сортировкой из стандартной библиотеки. Например `sortBy` или `std::sort` (в C++).

**Функции как результат**
В haskell все функции принимают ровно один аргумент и возвращают одно значение - которое может быть другой функцией. Это называется **каррированием**, и это фундаментальный принцип функционального программирования - если функция принимает несколько аргументов, она на самом деле возвращает функцию на каждом шаге.
Даже в простом примере:
```haskell
add :: Int -> Int -> Int
add x y = x + y
```
Тип Int -> Int -> Int на самом деле означает Int -> (Int -> Int) — то есть add принимает Int и возвращает функцию Int -> Int.

Функции можно возвращать и явно. Например, можно изменить нашу функцию `ifEven`. Если она принимает четный первый аргумент, то будет возвращена функция, которая увеличивает свой аргумент на 1, иначе - функция, которая увеличивает свой аргумент в 2 раза:
```haskell
module Main (main) where

ifEven :: Int -> (Int -> Int)
ifEven x = if even x
  then (\a -> a+1)
  else (\b -> b*2)

main :: IO ()
main = do
  let func = ifEven 21
  putStrLn $ show $ func 3
```
