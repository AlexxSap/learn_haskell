**Модули**

При помощи модулей моэжно группировать программные сущности в отдельные файлы. Это декларации самого верхнего уровня которые включают в себя остальные - функции, типы данных, классы типов и экземпляры типов.
В одном файле можно определить только один модуль. Делается это так:
```haskell
module ModuleName where
```

Имя модуля должно совпадать с именем файла (не обязательно, просто так транслятор сам найдёт нужный модуль) и начинаться с заглавной буквы. Строка определения модуля должна быть первой в файле (комментарии не в счёт).
При объявлении модуля можно инкапсулировать его содержание, сделав так, чтобы наружу торчали только нужные сущности. Для этого нужно их перечислить в скобках после имени файла:
```haskell
modele ModuleName (
    MyType0,
    MyType1 (...),
    MyType2 (WithOne, WithTwo)
    myFunction
) where
```

При этом у типов можно ограничить экспорт конструкторов. В примере выше у типа `MyType0` не экспортируются конструкторы и, следовательно, мне этого модуля будет доступен только идентификатор типа. Для `MyType1` экспортируются все конструкторы, а для `MyType2` - только перечисленные.

Импортировать модуль можно с помощью ключевого слова `import`. При этом можно указать имена сущностей, которые мы хотим импортировать (как в `Module2`) или импортировать все доступные (как в `Module1`). В стандартной библиотеке принято именование модулей, которое включает относительный путь к файлу модуля от точки входа в корневой каталог модуля. 
```haskell
import Module1
import Module2 (
    myFunction1,
    myFunction2
)
import Data.List -- лежит в data/list.hs
```

Естесвенно, что импортировать можно только те сущности, которые экспортируются указанным модулем, иначе будет ошибка. 
При конфликте имён сущностей в импортируемых модулях можно:
- скрыть идентификатор с помощью `hiding`
- использовать квалифицированный импорт (`qualified`). Тогда все сущности их модуля придётся предварять именем модуля. При это можно задать псевдоним модуля через `as`.
```haskell
import MyModule hiding (
    hidingFunction
)
import qualified OtherModule as OM
...
otherFunction data = map OM.otherFunction data
...
```

Так как экземпляры классов не имеют имён, то они экспортируются/импортируются всегда вместе с классами и типами для которых  определёны.
