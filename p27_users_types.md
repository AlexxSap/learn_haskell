**Создание собственных типов**

Создать собственный тип в haskell можно тремя способами - синоним типа, новый тип - обёртка и алгебраический тип данных. 

**Синонимы**

Создаются именно как синонимы существующего типа, то есть использование их равнозначно, но повышает читаемость. Объявляется с помощью ключевого слова `type`:
```haskell
type Name = String
type Surname = String
type Age = Int
```

Использование `type` не накладывает дополнительных гарантий безопасности типов. Это значит, что в функцию, которая принимает `Name` можно передать `Surname` или `String` и компилятор не заругает.

**Тип-обёртка**

Является абстракцией с нулевой стоимостью за счёт оптимизации компилятора. И в отличии от `type` добавляет действительно новый тип, который не приводится неявно к базовому типу.
```haskell
newtype Name = Name String
newtype Surname = Surname String

someFunc :: Name -> Bool
...
```
В таком случае в `someFunc` мы не сможем просто передать `Surname` или `String`.

**Алгебраические типы данных**

Позволяет создавать безопасные перечисления и комбинировать данные в структуры. 
```haskell
data Color = Red | Green | Blue

data Person = Person Surname Name
```

Вытащить значения `Surname` и `Name` из `Person` можно через сопоставление с образцом:
```haskell
getName :: Person -> Name
getName (Person n _) = n
```

Однако проще использовать **синтаксис записей**, который вводит именования для полей, которые так же являются функциями доступа:
```haskell
data Person = Person {
    name :: Name,
    surname :: Surname
}
...
somePerson = Person { name = "SomeName", surname = "SomeSurname"}
...
getName :: Person -> Name
getName = name
```

