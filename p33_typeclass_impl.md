**Реализация классов типов**

Иногда тривиальные реализации через `deriving` не подходят или не могут быть автоматически собраны. В этом случае писать реализацию придётся самому. А если есть собственные классы типов, то тут уже никуда не деться. Реализация классов типов выполняется с помощью ключевого слова `instance` и называется экземпляром. То есть в отличии от языков, реазизующих ООП, экземпляром именуется не конкретный объект, а, говоря языком ООП, класс реализующий интерфейс.
```haskell
data TrafficLight = Red | Yellow | Green

instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
    
instance Show TrafficLight where
    show Red = "Красный свет"
    show Yellow = "Жёлтый свет"
    show Green = "Зелёный свет"
```

В примере выше `TrafficLight` реализует классы типов `Eq` и `Show`. 
Хотя в классе `Eq` описаны функции `==` и `/=` следует переопределить только одну функцию в объявлении экземпляра класса. Это называется **минимальным полным определением класса типов** – имеется в виду минимум функций, которые надо реализовать, чтобы наш тип мог вести себя так, как предписано классом. Для класса `Ord` таким минимумом является метод `compare`, который возвращает значение типа `Ordering`. 

Именно через использование различных экземпляров классов типов реализуется **полиморфизм** в haskell. 
```haskell
someFunc :: (Bounded a, Enum a) => a -> a -> a
```

В примере выше, функция `someFunc` работает с любыми экземплярами классов `Bounded` и `Enum`.
