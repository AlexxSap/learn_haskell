**Реализация классов типов**

Иногда тривиальные реализации через `deriving` не подходят или не могут быть автоматически собраны. В этом случае писать реализацию придётся самому. А если есть собственные классы типов, то тут уже никуда не деться. Реализация классов типов выполняется с помощью ключевого слова `instance` и называется экземпляром. То есть в отличии от языков, реазизующих ООП, экземпляром именуется не конкретный объект, а, говоря языком ООП, класс реализующий интерфейс.
```haskell
data TrafficLight = Red | Yellow | Green

instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
    
instance Show TrafficLight where
    show Red = "Красный свет"
    show Yellow = "Жёлтый свет"
    show Green = "Зелёный свет"
```

В примере выше `TrafficLight` реализует классы типов `Eq` и `Show`. 
Хотя в классе `Eq` описаны функции `==` и `/=` следует переопределить только одну функцию в объявлении экземпляра класса. Это называется **минимальным полным определением ласса типов** – имеется в виду минимум функций, которые надо реализовать, чтобы наш тип мог вести себя так, как предписано классом. Для класса `Ord` таким минимумом является метод `compare`, который возвращает значение типа `Ordering`. 

Именно через использование различных экземпляров классов типов реализуются ограничения безудержного полиморфизм в haskell.
Можно записать такую функцию:
```haskell
sum x y = x + y
```
без описания сигнатуры. Если у вас отключены варнинги как ошибки (никогда так не делайте!!!), то такое запустится и даже будет работать, пока не случится страшное, и кто-то не захочет сложить число и строку. Тогда случится ошибка компиляции в месте вызова. Однако разумнее ограничить возможные типы для функции через указание классов типов, которые должен реализовывать аргумент функции:
```haskell
someFunc :: (Bounded a, Enum a) => a -> a -> a
```

Использование классов типов позволяет чётко выразить мысли разработчика, ограничив использование функций лишь экземплярами, которые обладают определённым поведением. В примере выше, функция `someFunc` работает с любыми экземплярами, которые реализуют одновременно классы типов `Bounded` и `Enum`.
