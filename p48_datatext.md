**Data.Text**

Кроме типа `String` в haskell для работы со строка еще существует тип `Text` из модуля `Data`. В отличии от `String`, который является `[Char]`, внутри `Data.Text` находится массив. Еще `Data.Text` не использует ленивые вычисления, а если они нужны, то есть тип `Data.Text.Lazy`.
Использование `Data.Text` более предпочтительно для решения реальных задач, чем `String`. `Text` лежит в памяти более компактно и итерировать по нему гораздо быстрее, чем по списку.

Модуль `Data.Text` предоставляет функции конвертации в `String` (однако применение их вычислительно дорого):
```haskell
Data.Text.pack :: String -> Data.Text.Internal.Text
Data.Text.unpack :: Data.Text.Internal.Text -> String
```
```
Internal в имени модуля - это распространённое соглашение в организации модулей. Это, как правило, модули, которые раскрывают внутреннюю структуру пакета и нарушают его инкапсуляцию. Делают это чтобы дать пользователям доступ к низкоуровневым функциям для максимальной производительности, не загромождать публичный интерфейс функциями, которые нужны только для связи внутренних частей библиотек.
```

Для того, чтобы не прописывать постоянно конвертацию строк вида "строка" в `Data.Text` нужно использовать расширение языка `OverloadedString`:
```haskell
{-# LANGUAGE OverloadedStrings #-}
import qualified Data.Text as T

someText :: T.Text
someText = "строка"
```

Почти каждая функция для работы со `String` имеет свой аналог для `Data.Text`:
- `lines` - разбиение строки по символу переноса на [Text]
- `unlines` - объединение строки символом переноса
- `words` - разбиение строки по любым пробельным символам
- `unwords` - объединяет строку пробелами
- `splitOn` - разделяет текст по подстроке
- `intercalate` - обратная `splitOn`

`Data.Text` является экземпляром `Semigroup` и `Monoid`, потому для него можно использовать `<>` и `mconcat` для объединения строк.
