**Чистые функции**

Чистые функции — это фундаментальное понятие в функциональном программировании и хорошей практике написания кода в целом. Они обладают двумя ключевыми свойствами:
1. Нет побочных эффектов - функция не изменяет состояние вне своего тела (не мутирует глобальные переменные, не изменяет входные аргументы, не пишет в файл, не отправляет HTTP-запросы и т.п.).
2. Детерминированность - при одинаковых входных аргументах функция всегда возвращает один и тот же результат, независимо от контекста или времени вызова.

**Преимущества чистых функций**

1. Предсказуемость. Поведение функции легко понять и протестировать: она зависит только от входных данных.
2. Лёгкость тестирования. Нет необходимости в моках, заглушках или подготовке состояния — просто передаёшь аргументы и проверяешь результат.
3. Повторное использование. Чистые функции легко переиспользовать в разных частях программы.
4. Параллелизм и многопоточность. Поскольку чистые функции не изменяют состояние, их можно безопасно выполнять параллельно.
5. Мемоизация (кеширование). Результат вызова чистой функции можно кэшировать по входным аргументам.
6. Референциальная прозрачность. Вызов функции можно заменить её результатом без изменения поведения программы.

**Где НЕЛЬЗЯ использовать чистые функции?**

Чистые функции не могут выполнять задачи, которые по своей природе изменяют состояние:
- Ввод/вывод (чтение файла, логирование, вывод в консоль)
- Работа с сетью (HTTP-запросы)
- Генерация случайных чисел
- Работа с текущим временем
- Изменение DOM в браузере
Однако такие "грязные" операции можно инкапсулировать на периферии программы, оставляя ядро приложения чистым.

**Почему Haskell — «чисто функциональный»?**

В Haskell все функции по умолчанию чистые. Это означает:
- Нельзя случайно произвести побочный эффект (например, изменить переменную или напечатать в консоль) из обычной функции.
- Побочные эффекты изолированы в специальных типах (например, `IO`).
- Это даёт ссылочную прозрачность: любой вызов функции можно заменить её результатом без изменения поведения программы.

В Haskell вы не можете написать "нечистую" функцию в обычном смысле — побочные эффекты обязательно упаковываются в монады, чаще всего в IO.
Haskell гарантирует чистоту на уровне системы типов:
- Если функция имеет тип `a -> b` (без `IO`, `State`, и т.д.), она обязана быть чистой.
- Компилятор не позволит вам вызвать putStrLn внутри такой функции.
