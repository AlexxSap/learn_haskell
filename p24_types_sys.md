**Система типов**

Система типов в языке haskell - одна из самых мощных и строгих среди современных языков программирования. Она обеспечивает безопасность типов на этапе компиляции, помогает избегать многих классов ошибок и делает код более выразительным и понятным. 

**Основные черты**
- Статическая типизация
Все типы определяются во время компиляции. Это означает, что программа не будет скомпилирована, если типы не согласованы.
- Сильная типизация
Haskell не позволяет неявных преобразований между типами. Например, нельзя сложить Int и String.
- Автоматический вывод типов 
Хотя типизация статическая, аннотации типов часто не обязательны - компилятор сам выводит типы на основе использования.
- Полиморфизм
Функции могут работать с любыми типами, не завися от их конкретной реализации (параметрический полиморфизм) или с типами, удовлетворяющими определённым ограничениям (ad-hoc полиморфизм через классы типов).

Всё это возможно благодаря использованию **модели типов Хиндли-Милнера (HM)**. 
Это классическая система типов, лежащая в основе многих функциональных языков, не только Haskell, но и ML, OCaml и F#. Она обеспечивает автоматический вывод типов для программ без необходимости явно указывать типы в большинстве случаев, при этом сохраняя статическую типизацию и безопасность.

**Основные идеи системы Хиндли–Милнера**
- Параметрический полиморфизм
HM поддерживает универсальный полиморфизм через схемы типов (type schemes), позволяя функциям работать с любыми типами, если это логически корректно.
- Вывод типов
Сердце HM - алгоритм Хиндли–Милнера, обычно реализуемый как алгоритм W (Algorithm W), разработанный Робином Милнером. Он позволяет автоматически определить наиболее общий тип выражения, используя унификацию. Например для выражения
```haskell
f x = x + 1
```
компилятор выводит тип:
```haskell
f :: Num a => a -> a
```
f :: Num a => a -> a

Потому что `+` требует, чтобы x принадлежал классу `Num` (в чистом HM нет классов типов — они добавлены в Haskell как расширение. Чистый HM работает с простыми типами без ограничений.).
- Лет-полиморфизм (Let-polymorphism)
Ключевая особенность HM: полиморфизм разрешён только для связываний `let` (или `where`), но не для аргументов функций.
- Типовые переменные и схемы
Тип — выражение вроде `Int`, `a -> b`, `[Bool]`. Схема типа — тип с кванторами: ∀a.a→a.
- Унификация (Unification)
Процесс нахождения подстановки, делающей два типа эквивалентными.
Пример:
Типы: `a -> b` и `Int -> c`
Унификация даёт: `a = Int`, `b = c`
Результат: `Int -> c` (с `c` как новая переменная)
Если унификация невозможна (например, `Int` и `Bool`), возникает ошибка типов.

**Ограничения HM**
- Нет полиморфизма высшего ранга (ранг-2 и выше) без расширений.
- Нет подтипов.
- Нет зависимых типов.
- Нет классов типов (это расширение Haskell).
- Мономорфные ограничения (в Haskell: Monomorphism Restriction).
Однако эти ограничения делают вывод типов разрешимым и эффективным (алгоритм W работает за почти линейное время в большинстве случаев).

**Связь с Haskell**
Haskell изначально основывался на HM. Но позже были добавлены:
- Классы типов (ad-hoc полиморфизм),
- Расширения: `RankNTypes`, `GADTs`, `TypeFamilies` и др.
Чистый HM не включает классы типов, но идея вывода наиболее общего типа сохраняется.
