**Частичное применение**

Это мощный механизм, который позволяет зафиксировать значения некоторых аргументов функции и на её основе получить функцию с меньшим количеством аргументов.
Например у нас есть функция `add` которая складывает два числа. На её основе можно создать функцию `increment`, которая выполняет увеличение аргумента на `1`.
```haskell
add :: Int -> Int -> Int
add x y = x + y

increment :: Int -> Int
increment = add 1
```

В языке haskell существует полезная практика
```
"Всякий раз, когда вы хотите использовать замыкание, нужно располагать аргументы функции в порядке от наиболее общего к наименее общему".
```
Это связано именно с использованием частичного применения и позволяет делать его более выразительным. Если же, вдруг, нужно частично применить второй аргумент, а не первый, то можно воспользоваться стандартной функцией `flip` - она меняет местами аргументы у функции с двумя аргументами:
```haskell
flip :: (a -> b -> c) -> b -> a -> c
```
Не трудно написать свой аналог `flip` для замены 3 и 4, 4 и 5 или еще полного порядка аргументов. Однако, такое легаси довольно поддерживать. 

Не стоит путать частичное применение с каррированием — это связанная, но другая концепция:
- **каррирование** — это преобразование функции от нескольких аргументов в цепочку функций от одного аргумента.
- **частичное применение** — это процесс применения функции к части её аргументов, чтобы получить новую функцию. Но в Haskell все функции изначально каррированы, поэтому частичное применение работает «из коробки».
