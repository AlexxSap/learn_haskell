**deriving**
 
Для нового типа можно автоматически сгенерировать необходимые для классов типов функции с помощью ключевого слова `deriving`. Это сработает если класс имеет тривиальную реализацию. 
```haskell
data Person = Person { 
    name :: String
  , age :: Int } 
deriving (Show, Eq)
```
Новые функции будут сгенерированы в процессе компиляции. Это может не получится, если класс сложный, тогда компилятор выдаст ошибку.
 
Классы типов могут зависеть от других классов типов. Например `Ord` зависит от `Eq`, значит перед реализацией `Ord` должен быть реализован `Eq`. Если же вы напишете только реализацию `Ord`, то получите ошибку при компиляции - `No instance for 'Eq имя_вашего_класса' ...`.
 
Отдельно стоит отметить автоматическую реализацию `Ord` для перечислений:
```haskell
data MyEnum = A | B | C | D deriving (Eq, Ord)
```
Компилятор будет использовать порядок следования конструкторов данных (`A | B | C | D`) для реализации упорядочивания экземпляров `MyEnum`, то есть стандартно `B` будет меньше `C`, но больше `A`.
