**Рекурсия**

В функциональном программировании нет циклов. Это значит, что все итерационные задачи должны решаться через рекурсию. Для людей, которые уже имеют опыт работы с императивными языками, понятие рекурсии кажется сложным. Хотя почти все повторяющиеся действия в нашей жизни имеют рекурсивное описание.

Функция называется **рекурсивной**, если она вызывает саму себя в своём определении.
**Главное правило** при работе с рекурсивными алгоритмами - точно знать, когда нужно выходить из рекурсии (базовый случай).

Самыми распространёнными и заезженными примерами работы с рекурсией являются вычисление факториала и наибольшего общего делителя. Но в haskell рекурсия применяется еще, например, для работы со списками:
```haskell
-- вычисление длины списка
length' :: [a] -> Int
length' []     = 0
length' (_:xs) = 1 + length' xs

-- сумма элементов списка
sum' :: Num a => [a] -> a
sum' []     = 0
sum' (x:xs) = x + sum' xs
```

**Оптимизация хвостовой рекурсии**

Программисты не любят рекурсию еще за то, что она сильно расходует оперативку. При шаге рекурсивного алгоритма нужно запомнить стэк текущего вызова, чтобык расрутить алгоритм обратно. Однако, если рекурсивный вызов является последней операцией в функции (хвостовая рекурсия) и в неё передаяются все нужные данные как аргументы, то компилятор оптимизирует этот вызов и избежать роста стэка. 
